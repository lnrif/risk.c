let {*} = Result::{Ok, Err};
let Result[E: type] = enum { Ok(()), Err(E) };
let Result[T: type, E: type] = enum { Ok(T), Err(E) };

fn main() {
	let mut file = File::open("a.txt") orelse @panic();
	file.write("Hello world!\n") orelse @panic();
	file.flush() orelse @panic();
	file.close() orelse @panic();
}

[|inline(always)|]
fn save(path: &[~:0]u8, buf: &[]u8) {
    @todo();
}

pub let File = struct {
	handle: usize,
	comptime flushed: bool,
};

impl File {
	pub fn open(path: &[:0]u8) Result[File, OpenError] {
		Self { handle: ..., flushed: true }
	}
}

impl File {	
	pub fn write(&mut self, bytes: &[]u8) Result[CloseError] {
		if ... return Err(CloseError::...);
		self.flushed = false;
		return Ok();
	}
}

impl File if !self.flushed {
	[|drop|]
	pub fn flush(&mut self) Result[FlushError] {
		if ... return Err(FlushError::...);
		self.flushed = true;
		return Ok();
	}
}

impl File if self.flushed {
	[|drop|]
	pub fn close(self) -> Result[CloseError] {
		if ... return Err(CloseError::...);
		return Ok();
	}
};

let OpenError  = enum { ... };
let WriteError = enum { ... };
let FlushError = enum { ... };